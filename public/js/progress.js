/**
 * Walking out Chaos - Progress Tracking JavaScript
 * Generated by Frontend Agent FE-001
 */

class ProgressTracker {
    constructor(app) {
        this.app = app;
        this.chartInstance = null;
        this.progressData = null;
        
        this.log('Progress Tracker component initialized');
    }
    
    /**
     * Initialize page
     */
    initializePage() {
        this.loadProgressData();
        this.updateProgressStats();
        this.initializeChart();
    }
    
    /**
     * Load progress data from localStorage
     */
    loadProgressData() {
        try {
            const assessments = JSON.parse(localStorage.getItem('wooc_assessments') || '[]');
            const transformations = JSON.parse(localStorage.getItem('wooc_transformation_flows') || '[]');
            const activities = JSON.parse(localStorage.getItem('wooc_recent_activities') || '[]');
            
            this.progressData = {
                assessments: assessments,
                transformations: transformations,
                activities: activities,
                stats: this.calculateStats(assessments, transformations)
            };
            
            this.log('Progress data loaded', {
                assessments: assessments.length,
                transformations: transformations.length,
                activities: activities.length
            });
            
        } catch (error) {
            this.log('Error loading progress data', error);
            this.progressData = {
                assessments: [],
                transformations: [],
                activities: [],
                stats: this.getDefaultStats()
            };
        }
    }
    
    /**
     * Calculate statistics from data
     */
    calculateStats(assessments, transformations) {
        if (assessments.length === 0) {
            return this.getDefaultStats();
        }
        
        // Calculate average chaos score
        const chaosScores = assessments.map(a => a.chaos_score);
        const avgChaosScore = chaosScores.reduce((sum, score) => sum + score, 0) / chaosScores.length;
        
        // Calculate improvement trend
        const improvementTrend = this.calculateImprovementTrend(chaosScores);
        
        // Count sessions completed
        const sessionsCompleted = transformations.length;
        
        // Calculate streak
        const currentStreak = this.calculateCurrentStreak(assessments);
        
        // Calculate best chaos score
        const bestChaosScore = Math.min(...chaosScores);
        
        // Calculate total time invested
        const totalTimeInvested = transformations.reduce((sum, t) => sum + (t.duration || 0), 0);
        
        return {
            avgChaosScore: Math.round(avgChaosScore * 10) / 10,
            improvementTrend: improvementTrend,
            sessionsCompleted: sessionsCompleted,
            currentStreak: currentStreak,
            bestChaosScore: bestChaosScore,
            totalTimeInvested: totalTimeInvested,
            lastAssessment: assessments[assessments.length - 1],
            recentTransformations: transformations.slice(-5)
        };
    }
    
    /**
     * Get default stats for empty data
     */
    getDefaultStats() {
        return {
            avgChaosScore: 0,
            improvementTrend: 0,
            sessionsCompleted: 0,
            currentStreak: 0,
            bestChaosScore: 0,
            totalTimeInvested: 0,
            lastAssessment: null,
            recentTransformations: []
        };
    }
    
    /**
     * Calculate improvement trend
     */
    calculateImprovementTrend(chaosScores) {
        if (chaosScores.length < 2) return 0;
        
        const recentCount = Math.min(5, chaosScores.length);
        const recentScores = chaosScores.slice(-recentCount);
        const olderScores = chaosScores.slice(0, -recentCount);
        
        if (olderScores.length === 0) return 0;
        
        const recentAvg = recentScores.reduce((sum, score) => sum + score, 0) / recentScores.length;
        const olderAvg = olderScores.reduce((sum, score) => sum + score, 0) / olderScores.length;
        
        // Lower chaos score is better, so improvement is negative change
        return Math.round((olderAvg - recentAvg) * 10) / 10;
    }
    
    /**
     * Calculate current streak
     */
    calculateCurrentStreak(assessments) {
        if (assessments.length === 0) return 0;
        
        // Calculate streak of daily usage
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        
        let streak = 0;
        let currentDate = new Date(today);
        
        for (let i = assessments.length - 1; i >= 0; i--) {
            const assessmentDate = new Date(assessments[i].timestamp);
            assessmentDate.setHours(0, 0, 0, 0);
            
            if (assessmentDate.getTime() === currentDate.getTime()) {
                streak++;
                currentDate.setDate(currentDate.getDate() - 1);
            } else if (assessmentDate.getTime() < currentDate.getTime()) {
                break;
            }
        }
        
        return streak;
    }
    
    /**
     * Update progress statistics display
     */
    updateProgressStats() {
        if (!this.progressData) return;
        
        const stats = this.progressData.stats;
        
        // Update average chaos score
        const avgChaosScoreElement = document.getElementById('avgChaosScore');
        if (avgChaosScoreElement) {
            avgChaosScoreElement.textContent = stats.avgChaosScore || '--';
        }
        
        // Update sessions completed
        const sessionsCompletedElement = document.getElementById('sessionsCompleted');
        if (sessionsCompletedElement) {
            sessionsCompletedElement.textContent = stats.sessionsCompleted || '--';
        }
        
        // Update improvement trend
        const improvementTrendElement = document.getElementById('improvementTrend');
        if (improvementTrendElement) {
            const trend = stats.improvementTrend;
            if (trend > 0) {
                improvementTrendElement.textContent = `+${trend}`;
                improvementTrendElement.className = 'stat-value positive-trend';
            } else if (trend < 0) {
                improvementTrendElement.textContent = trend.toString();
                improvementTrendElement.className = 'stat-value negative-trend';
            } else {
                improvementTrendElement.textContent = '0';
                improvementTrendElement.className = 'stat-value neutral-trend';
            }
        }
        
        // Add additional stats if elements exist
        this.updateAdditionalStats(stats);
    }
    
    /**
     * Update additional statistics
     */
    updateAdditionalStats(stats) {
        // Current streak
        const streakElement = document.getElementById('currentStreak');
        if (streakElement) {
            const streakText = stats.currentStreak === 1 ? '1 day' : `${stats.currentStreak} days`;
            streakElement.textContent = stats.currentStreak > 0 ? streakText : '--';
        }
        
        // Best chaos score
        const bestScoreElement = document.getElementById('bestChaosScore');
        if (bestScoreElement) {
            bestScoreElement.textContent = stats.bestChaosScore || '--';
        }
        
        // Total time invested
        const totalTimeElement = document.getElementById('totalTimeInvested');
        if (totalTimeElement) {
            totalTimeElement.textContent = this.formatDuration(stats.totalTimeInvested);
        }
        
        // Recent activity summary
        this.updateRecentActivity();
    }
    
    /**
     * Update recent activity summary
     */
    updateRecentActivity() {
        const recentActivityElement = document.getElementById('progressRecentActivity');
        if (!recentActivityElement || !this.progressData) return;
        
        const activities = this.progressData.activities.slice(0, 10);
        
        if (activities.length === 0) {
            recentActivityElement.innerHTML = '<p class="no-activity">No recent activity</p>';
            return;
        }
        
        const activityHtml = activities.map(activity => `
            <div class="activity-item">
                <div class="activity-time">${this.formatTimeAgo(activity.timestamp)}</div>
                <div class="activity-description">${activity.description}</div>
            </div>
        `).join('');
        
        recentActivityElement.innerHTML = `
            <h4>Recent Activity</h4>
            <div class="activity-list">
                ${activityHtml}
            </div>
        `;
    }
    
    /**
     * Initialize chaos score chart
     */
    initializeChart() {
        const chartCanvas = document.getElementById('chaosChart');
        if (!chartCanvas || !this.progressData) return;
        
        const ctx = chartCanvas.getContext('2d');
        if (!ctx) return;
        
        const chartData = this.prepareChartData();
        
        // Simple chart implementation (would use Chart.js in production)
        this.drawSimpleChart(ctx, chartData);
    }
    
    /**
     * Prepare chart data
     */
    prepareChartData() {
        if (!this.progressData.assessments.length) {
            return {
                labels: ['No data'],
                values: [0],
                isEmpty: true
            };
        }
        
        const assessments = this.progressData.assessments;
        const maxDataPoints = 30; // Show last 30 assessments
        
        const recentAssessments = assessments.slice(-maxDataPoints);
        
        const labels = recentAssessments.map((assessment, index) => {
            const date = new Date(assessment.timestamp);
            return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        });
        
        const values = recentAssessments.map(assessment => assessment.chaos_score);
        
        return {
            labels: labels,
            values: values,
            isEmpty: false
        };
    }
    
    /**
     * Draw simple chart (fallback for Chart.js)
     */
    drawSimpleChart(ctx, data) {
        const canvas = ctx.canvas;
        const width = canvas.width;
        const height = canvas.height;
        
        // Clear canvas
        ctx.clearRect(0, 0, width, height);
        
        if (data.isEmpty) {
            this.drawEmptyChart(ctx, width, height);
            return;
        }
        
        const padding = 60;
        const chartWidth = width - 2 * padding;
        const chartHeight = height - 2 * padding;
        
        // Draw axes
        this.drawAxes(ctx, padding, chartWidth, chartHeight);
        
        // Draw grid
        this.drawGrid(ctx, padding, chartWidth, chartHeight);
        
        // Draw line chart
        this.drawLineChart(ctx, data, padding, chartWidth, chartHeight);
        
        // Draw labels
        this.drawChartLabels(ctx, data, padding, chartWidth, chartHeight);
    }
    
    /**
     * Draw empty chart placeholder
     */
    drawEmptyChart(ctx, width, height) {
        ctx.fillStyle = '#666666';
        ctx.font = '16px Inter';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('Complete an assessment to see your progress', width / 2, height / 2);
    }
    
    /**
     * Draw chart axes
     */
    drawAxes(ctx, padding, chartWidth, chartHeight) {
        ctx.strokeStyle = '#444444';
        ctx.lineWidth = 2;
        
        ctx.beginPath();
        // Y-axis
        ctx.moveTo(padding, padding);
        ctx.lineTo(padding, padding + chartHeight);
        // X-axis
        ctx.lineTo(padding + chartWidth, padding + chartHeight);
        ctx.stroke();
    }
    
    /**
     * Draw chart grid
     */
    drawGrid(ctx, padding, chartWidth, chartHeight) {
        ctx.strokeStyle = '#333333';
        ctx.lineWidth = 1;
        
        // Horizontal grid lines (chaos score levels)
        for (let i = 1; i <= 10; i++) {
            const y = padding + chartHeight - (i / 10) * chartHeight;
            
            ctx.beginPath();
            ctx.moveTo(padding, y);
            ctx.lineTo(padding + chartWidth, y);
            ctx.stroke();
        }
        
        // Vertical grid lines (time intervals)
        const dataPoints = Math.max(1, this.progressData.assessments.length);
        const interval = Math.max(1, Math.floor(dataPoints / 10));
        
        for (let i = 0; i < dataPoints; i += interval) {
            const x = padding + (i / (dataPoints - 1)) * chartWidth;
            
            ctx.beginPath();
            ctx.moveTo(x, padding);
            ctx.lineTo(x, padding + chartHeight);
            ctx.stroke();
        }
    }
    
    /**
     * Draw line chart
     */
    drawLineChart(ctx, data, padding, chartWidth, chartHeight) {
        if (data.values.length < 2) return;
        
        const values = data.values;
        const maxValue = 10; // Chaos score is 1-10
        const minValue = 1;
        
        // Create gradient
        const gradient = ctx.createLinearGradient(0, padding, 0, padding + chartHeight);
        gradient.addColorStop(0, 'rgba(255, 68, 68, 0.8)'); // Red (high chaos)
        gradient.addColorStop(0.5, 'rgba(255, 136, 0, 0.8)'); // Orange (medium chaos)
        gradient.addColorStop(1, 'rgba(0, 255, 136, 0.8)'); // Green (low chaos)
        
        ctx.strokeStyle = gradient;
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        // Draw line
        ctx.beginPath();
        values.forEach((value, index) => {
            const x = padding + (index / (values.length - 1)) * chartWidth;
            const y = padding + chartHeight - ((value - minValue) / (maxValue - minValue)) * chartHeight;
            
            if (index === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        });
        ctx.stroke();
        
        // Draw data points
        ctx.fillStyle = '#00d4ff';
        values.forEach((value, index) => {
            const x = padding + (index / (values.length - 1)) * chartWidth;
            const y = padding + chartHeight - ((value - minValue) / (maxValue - minValue)) * chartHeight;
            
            ctx.beginPath();
            ctx.arc(x, y, 4, 0, 2 * Math.PI);
            ctx.fill();
        });
    }
    
    /**
     * Draw chart labels
     */
    drawChartLabels(ctx, data, padding, chartWidth, chartHeight) {
        ctx.fillStyle = '#cccccc';
        ctx.font = '12px Inter';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        
        // Y-axis labels (chaos scores)
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        for (let i = 1; i <= 10; i++) {
            const y = padding + chartHeight - (i / 10) * chartHeight;
            ctx.fillText(i.toString(), padding - 10, y);
        }
        
        // X-axis labels (dates)
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        const labelInterval = Math.max(1, Math.floor(data.labels.length / 6));
        
        data.labels.forEach((label, index) => {
            if (index % labelInterval === 0) {
                const x = padding + (index / (data.labels.length - 1)) * chartWidth;
                ctx.fillText(label, x, padding + chartHeight + 10);
            }
        });
    }
    
    /**
     * Export progress data
     */
    exportProgressData() {
        if (!this.progressData) {
            this.app.showNotification('No data to export', 'warning');
            return;
        }
        
        const exportData = {
            exported_at: new Date().toISOString(),
            app_version: '1.0.0',
            user_data: this.progressData
        };
        
        const dataStr = JSON.stringify(exportData, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        
        const link = document.createElement('a');
        link.href = URL.createObjectURL(dataBlob);
        link.download = `wooc-progress-${new Date().toISOString().split('T')[0]}.json`;
        
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        this.app.showNotification('Progress data exported successfully', 'success');
        this.log('Progress data exported');
    }
    
    /**
     * Import progress data
     */
    importProgressData() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        
        input.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const importedData = JSON.parse(event.target.result);
                    
                    if (this.validateImportedData(importedData)) {
                        this.mergeImportedData(importedData.user_data);
                        this.loadProgressData();
                        this.updateProgressStats();
                        this.initializeChart();
                        
                        this.app.showNotification('Progress data imported successfully', 'success');
                        this.log('Progress data imported');
                    } else {
                        this.app.showNotification('Invalid data format', 'error');
                    }
                } catch (error) {
                    this.app.showNotification('Error importing data', 'error');
                    this.log('Error importing progress data', error);
                }
            };
            
            reader.readAsText(file);
        };
        
        input.click();
    }
    
    /**
     * Validate imported data
     */
    validateImportedData(data) {
        return data && 
               data.user_data && 
               Array.isArray(data.user_data.assessments) &&
               Array.isArray(data.user_data.transformations) &&
               Array.isArray(data.user_data.activities);
    }
    
    /**
     * Merge imported data with existing data
     */
    mergeImportedData(importedData) {
        try {
            // Merge assessments
            const existingAssessments = JSON.parse(localStorage.getItem('wooc_assessments') || '[]');
            const mergedAssessments = this.mergeArrays(existingAssessments, importedData.assessments, 'timestamp');
            localStorage.setItem('wooc_assessments', JSON.stringify(mergedAssessments));
            
            // Merge transformations
            const existingTransformations = JSON.parse(localStorage.getItem('wooc_transformation_flows') || '[]');
            const mergedTransformations = this.mergeArrays(existingTransformations, importedData.transformations, 'timestamp');
            localStorage.setItem('wooc_transformation_flows', JSON.stringify(mergedTransformations));
            
            // Merge activities
            const existingActivities = JSON.parse(localStorage.getItem('wooc_recent_activities') || '[]');
            const mergedActivities = this.mergeArrays(existingActivities, importedData.activities, 'timestamp');
            localStorage.setItem('wooc_recent_activities', JSON.stringify(mergedActivities));
            
        } catch (error) {
            this.log('Error merging imported data', error);
            throw error;
        }
    }
    
    /**
     * Merge arrays avoiding duplicates
     */
    mergeArrays(existing, imported, keyField) {
        const existingKeys = new Set(existing.map(item => item[keyField]));
        const newItems = imported.filter(item => !existingKeys.has(item[keyField]));
        
        return [...existing, ...newItems].sort((a, b) => a[keyField] - b[keyField]);
    }
    
    /**
     * Clear all progress data
     */
    clearProgressData() {
        if (confirm('Are you sure you want to clear all progress data? This action cannot be undone.')) {
            localStorage.removeItem('wooc_assessments');
            localStorage.removeItem('wooc_transformation_flows');
            localStorage.removeItem('wooc_recent_activities');
            
            this.loadProgressData();
            this.updateProgressStats();
            this.initializeChart();
            
            this.app.showNotification('Progress data cleared', 'success');
            this.log('Progress data cleared');
        }
    }
    
    /**
     * Generate progress report
     */
    generateProgressReport() {
        if (!this.progressData || this.progressData.assessments.length === 0) {
            this.app.showNotification('No data available for report', 'warning');
            return;
        }
        
        const report = this.createProgressReport();
        this.displayProgressReport(report);
    }
    
    /**
     * Create progress report
     */
    createProgressReport() {
        const stats = this.progressData.stats;
        const assessments = this.progressData.assessments;
        const transformations = this.progressData.transformations;
        
        const firstAssessment = assessments[0];
        const lastAssessment = assessments[assessments.length - 1];
        const timeSpan = lastAssessment.timestamp - firstAssessment.timestamp;
        const daysTracked = Math.ceil(timeSpan / (24 * 60 * 60 * 1000));
        
        return {
            summary: {
                total_assessments: assessments.length,
                total_transformations: transformations.length,
                days_tracked: daysTracked,
                average_chaos_score: stats.avgChaosScore,
                improvement_trend: stats.improvementTrend,
                current_streak: stats.currentStreak
            },
            insights: this.generateProgressInsights(stats, assessments, transformations),
            recommendations: this.generateRecommendations(stats, assessments, transformations)
        };
    }
    
    /**
     * Generate progress insights
     */
    generateProgressInsights(stats, assessments, transformations) {
        const insights = [];
        
        // Improvement analysis
        if (stats.improvementTrend > 1) {
            insights.push(`Your chaos scores have improved by ${stats.improvementTrend} points on average - excellent progress!`);
        } else if (stats.improvementTrend > 0) {
            insights.push(`You're showing steady improvement with a ${stats.improvementTrend} point reduction in chaos.`);
        } else if (stats.improvementTrend < -1) {
            insights.push(`Your chaos scores have increased recently. Consider more frequent transformations.`);
        } else {
            insights.push(`Your chaos levels are relatively stable. Consistency is key to improvement.`);
        }
        
        // Usage patterns
        const avgAssessmentsPerWeek = (assessments.length / stats.currentStreak) * 7;
        if (avgAssessmentsPerWeek > 7) {
            insights.push(`You're very engaged with daily assessments - this consistency will drive results.`);
        } else if (avgAssessmentsPerWeek > 3) {
            insights.push(`Good assessment frequency. Try to maintain regular check-ins.`);
        } else {
            insights.push(`Consider more frequent assessments to better track your progress.`);
        }
        
        // Transformation effectiveness
        if (transformations.length > 0) {
            const avgDuration = transformations.reduce((sum, t) => sum + t.duration, 0) / transformations.length;
            if (avgDuration > 600000) { // 10 minutes
                insights.push(`You invest good time in transformations (${this.formatDuration(avgDuration)} average).`);
            } else {
                insights.push(`Try spending more time on transformations for better results.`);
            }
        }
        
        return insights;
    }
    
    /**
     * Generate recommendations
     */
    generateRecommendations(stats, assessments, transformations) {
        const recommendations = [];
        
        // Based on average chaos score
        if (stats.avgChaosScore > 7) {
            recommendations.push('Focus on daily stress reduction techniques');
            recommendations.push('Try the Breathing Bridge transformation more frequently');
            recommendations.push('Consider professional support for stress management');
        } else if (stats.avgChaosScore > 5) {
            recommendations.push('Use Thought Sorting to organize daily challenges');
            recommendations.push('Practice Mind Decluttering weekly');
        } else {
            recommendations.push('Maintain your good mental organization habits');
            recommendations.push('Help others by sharing what works for you');
        }
        
        // Based on usage patterns
        if (stats.currentStreak < 7) {
            recommendations.push('Build a daily assessment habit for better tracking');
        }
        
        if (transformations.length < assessments.length * 0.3) {
            recommendations.push('Try more transformation flows to actively improve your state');
        }
        
        return recommendations;
    }
    
    /**
     * Display progress report
     */
    displayProgressReport(report) {
        const reportHtml = `
            <div class="progress-report-modal">
                <div class="progress-report-content">
                    <div class="report-header">
                        <h2>Progress Report</h2>
                        <button class="close-report" onclick="progressTracker.closeProgressReport()">Ã—</button>
                    </div>
                    
                    <div class="report-summary">
                        <h3>Summary</h3>
                        <div class="summary-stats">
                            <div class="summary-stat">
                                <span class="stat-label">Total Assessments</span>
                                <span class="stat-value">${report.summary.total_assessments}</span>
                            </div>
                            <div class="summary-stat">
                                <span class="stat-label">Transformations</span>
                                <span class="stat-value">${report.summary.total_transformations}</span>
                            </div>
                            <div class="summary-stat">
                                <span class="stat-label">Days Tracked</span>
                                <span class="stat-value">${report.summary.days_tracked}</span>
                            </div>
                            <div class="summary-stat">
                                <span class="stat-label">Average Chaos</span>
                                <span class="stat-value">${report.summary.average_chaos_score}</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="report-insights">
                        <h3>Insights</h3>
                        <ul>
                            ${report.insights.map(insight => `<li>${insight}</li>`).join('')}
                        </ul>
                    </div>
                    
                    <div class="report-recommendations">
                        <h3>Recommendations</h3>
                        <ul>
                            ${report.recommendations.map(rec => `<li>${rec}</li>`).join('')}
                        </ul>
                    </div>
                    
                    <div class="report-actions">
                        <button class="btn btn-primary" onclick="progressTracker.exportProgressData()">
                            Export Data
                        </button>
                        <button class="btn btn-secondary" onclick="progressTracker.closeProgressReport()">
                            Close
                        </button>
                    </div>
                </div>
            </div>
        `;
        
        // Add to page
        document.body.insertAdjacentHTML('beforeend', reportHtml);
    }
    
    /**
     * Close progress report
     */
    closeProgressReport() {
        const modal = document.querySelector('.progress-report-modal');
        if (modal) {
            modal.remove();
        }
    }
    
    /**
     * Format duration
     */
    formatDuration(ms) {
        if (!ms || ms === 0) return '--';
        
        const hours = Math.floor(ms / 3600000);
        const minutes = Math.floor((ms % 3600000) / 60000);
        
        if (hours > 0) {
            return `${hours}h ${minutes}m`;
        } else if (minutes > 0) {
            return `${minutes}m`;
        } else {
            return '<1m';
        }
    }
    
    /**
     * Format time ago
     */
    formatTimeAgo(timestamp) {
        const now = Date.now();
        const diff = now - timestamp;
        
        const minutes = Math.floor(diff / 60000);
        const hours = Math.floor(diff / 3600000);
        const days = Math.floor(diff / 86400000);
        
        if (days > 0) {
            return `${days}d ago`;
        } else if (hours > 0) {
            return `${hours}h ago`;
        } else if (minutes > 0) {
            return `${minutes}m ago`;
        } else {
            return 'Just now';
        }
    }
    
    /**
     * Log events
     */
    log(message, data = null) {
        const timestamp = new Date().toISOString();
        console.log(`[ProgressTracker] [${timestamp}] ${message}`, data);
    }
}

// Add progress report modal styles
const progressReportStyles = `
.progress-report-modal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
}

.progress-report-content {
    background: rgba(26, 26, 46, 0.95);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 16px;
    padding: 2rem;
    max-width: 600px;
    max-height: 80vh;
    overflow-y: auto;
    color: white;
}

.report-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1.5rem;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    padding-bottom: 1rem;
}

.close-report {
    background: none;
    border: none;
    color: #cccccc;
    font-size: 2rem;
    cursor: pointer;
    padding: 0;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.close-report:hover {
    color: #ffffff;
}

.summary-stats {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 1rem;
    margin: 1rem 0;
}

.summary-stat {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 8px;
    padding: 1rem;
    text-align: center;
}

.summary-stat .stat-label {
    display: block;
    font-size: 0.9rem;
    color: #cccccc;
    margin-bottom: 0.5rem;
}

.summary-stat .stat-value {
    display: block;
    font-size: 1.5rem;
    font-weight: 600;
    color: #00d4ff;
}

.report-insights, .report-recommendations {
    margin: 1.5rem 0;
}

.report-insights ul, .report-recommendations ul {
    list-style: none;
    padding: 0;
}

.report-insights li, .report-recommendations li {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 8px;
    padding: 1rem;
    margin-bottom: 0.5rem;
    border-left: 4px solid #00d4ff;
}

.report-actions {
    display: flex;
    gap: 1rem;
    justify-content: center;
    margin-top: 2rem;
    padding-top: 1rem;
    border-top: 1px solid rgba(255, 255, 255, 0.1);
}

.positive-trend { color: #00ff88; }
.negative-trend { color: #ff4444; }
.neutral-trend { color: #cccccc; }

.activity-list {
    max-height: 300px;
    overflow-y: auto;
}

.activity-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.5rem 0;
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
}

.activity-time {
    font-size: 0.8rem;
    color: #888888;
    white-space: nowrap;
}

.activity-description {
    flex: 1;
    margin-left: 1rem;
    color: #cccccc;
}

.no-activity {
    text-align: center;
    color: #666666;
    font-style: italic;
    padding: 2rem;
}
`;

// Add styles to page
const styleSheet = document.createElement('style');
styleSheet.textContent = progressReportStyles;
document.head.appendChild(styleSheet);

// Global functions for inline handlers
window.progressTracker = null;

// Initialize when app is ready
document.addEventListener('DOMContentLoaded', () => {
    if (window.woocApp) {
        window.progressTracker = new ProgressTracker(window.woocApp);
    }
});