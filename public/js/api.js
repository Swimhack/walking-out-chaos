/**
 * Walking out Chaos - API Communication JavaScript
 * Generated by Frontend Agent FE-001
 */

class WOOCApi {
    constructor() {
        this.baseUrl = this.getApiBaseUrl();
        this.apiKey = null;
        this.sessionToken = null;
        this.isOnline = navigator.onLine;
        this.requestQueue = [];
        this.retryQueue = [];
        
        // Initialize API client
        this.initializeApi();
        
        this.log('WOOC API client initialized', { baseUrl: this.baseUrl });
    }
    
    /**
     * Initialize API client
     */
    initializeApi() {
        // Set up online/offline detection
        window.addEventListener('online', () => {
            this.isOnline = true;
            this.processOfflineQueue();
        });
        
        window.addEventListener('offline', () => {
            this.isOnline = false;
        });
        
        // Load stored session token
        this.loadSessionToken();
        
        // Set up automatic retry for failed requests
        this.setupRetrySystem();
    }
    
    /**
     * Get API base URL
     */
    getApiBaseUrl() {
        // Development detection
        if (location.hostname === 'localhost' || location.hostname === '127.0.0.1') {
            return location.origin + '/api/v1';
        }
        
        // For Netlify deployment, use serverless functions
        if (location.hostname.includes('netlify.app') || location.hostname.includes('netlify.com')) {
            return location.origin + '/.netlify/functions/api/v1';
        }
        
        // Production URL
        return location.origin + '/api/v1';
    }
    
    /**
     * Load session token from storage
     */
    loadSessionToken() {
        try {
            const token = localStorage.getItem('wooc_session_token');
            if (token) {
                this.sessionToken = token;
                this.log('Session token loaded');
            }
        } catch (error) {
            this.log('Error loading session token', error);
        }
    }
    
    /**
     * Save session token to storage
     */
    saveSessionToken(token) {
        try {
            this.sessionToken = token;
            localStorage.setItem('wooc_session_token', token);
            this.log('Session token saved');
        } catch (error) {
            this.log('Error saving session token', error);
        }
    }
    
    /**
     * Clear session token
     */
    clearSessionToken() {
        this.sessionToken = null;
        localStorage.removeItem('wooc_session_token');
        this.log('Session token cleared');
    }
    
    /**
     * Make API request
     */
    async makeRequest(endpoint, options = {}) {
        const url = `${this.baseUrl}${endpoint}`;
        const requestId = this.generateRequestId();
        
        // Default options
        const defaultOptions = {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
                'X-Request-ID': requestId
            },
            timeout: 10000
        };
        
        // Merge options
        const requestOptions = { ...defaultOptions, ...options };
        
        // Add authentication headers
        if (this.sessionToken) {
            requestOptions.headers['Authorization'] = `Bearer ${this.sessionToken}`;
        }
        
        // Add CSRF token if available
        const csrfToken = this.getCsrfToken();
        if (csrfToken) {
            requestOptions.headers['X-CSRF-Token'] = csrfToken;
        }
        
        this.log('Making API request', { url, method: requestOptions.method, requestId });
        
        try {
            // Check if online
            if (!this.isOnline && options.requireOnline !== false) {
                throw new Error('No internet connection');
            }
            
            // Make request with timeout
            const response = await this.fetchWithTimeout(url, requestOptions);
            
            // Handle response
            return await this.handleResponse(response, requestId);
            
        } catch (error) {
            return this.handleRequestError(error, endpoint, options, requestId);
        }
    }
    
    /**
     * Fetch with timeout
     */
    async fetchWithTimeout(url, options) {
        const timeout = options.timeout || 10000;
        
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        
        try {
            const response = await fetch(url, {
                ...options,
                signal: controller.signal
            });
            
            clearTimeout(timeoutId);
            return response;
            
        } catch (error) {
            clearTimeout(timeoutId);
            throw error;
        }
    }
    
    /**
     * Handle API response
     */
    async handleResponse(response, requestId) {
        const contentType = response.headers.get('content-type');
        
        // Parse response body
        let data;
        if (contentType && contentType.includes('application/json')) {
            data = await response.json();
        } else {
            data = await response.text();
        }
        
        // Log response
        this.log('API response received', {
            status: response.status,
            requestId: requestId,
            hasData: !!data
        });
        
        // Handle HTTP errors
        if (!response.ok) {
            const error = new Error(data.message || `HTTP ${response.status}`);
            error.status = response.status;
            error.data = data;
            error.requestId = requestId;
            throw error;
        }
        
        // Update session token if provided
        if (data.session_token) {
            this.saveSessionToken(data.session_token);
        }
        
        return {
            data: data,
            status: response.status,
            headers: response.headers,
            requestId: requestId
        };
    }
    
    /**
     * Handle request errors
     */
    async handleRequestError(error, endpoint, options, requestId) {
        this.log('API request error', { error: error.message, endpoint, requestId });
        
        // Handle specific error types
        if (error.name === 'AbortError') {
            error.message = 'Request timeout';
        } else if (error.status === 401) {
            // Unauthorized - clear session and redirect to login
            this.clearSessionToken();
            error.message = 'Authentication required';
        } else if (error.status === 403) {
            error.message = 'Access forbidden';
        } else if (error.status === 404) {
            error.message = 'Resource not found';
        } else if (error.status >= 500) {
            // Server error - add to retry queue
            this.addToRetryQueue(endpoint, options, requestId);
            error.message = 'Server error - will retry automatically';
        } else if (!this.isOnline) {
            // Offline - add to offline queue
            this.addToOfflineQueue(endpoint, options, requestId);
            error.message = 'Offline - will sync when online';
        }
        
        // Return error response
        return {
            error: error,
            status: error.status || 0,
            requestId: requestId
        };
    }
    
    /**
     * Authentication endpoints
     */
    async login(email, password) {
        return this.makeRequest('/auth/login', {
            method: 'POST',
            body: JSON.stringify({ email, password })
        });
    }
    
    async logout() {
        const result = await this.makeRequest('/auth/logout', {
            method: 'POST'
        });
        
        this.clearSessionToken();
        return result;
    }
    
    async register(userData) {
        return this.makeRequest('/auth/register', {
            method: 'POST',
            body: JSON.stringify(userData)
        });
    }
    
    /**
     * Assessment endpoints
     */
    async submitAssessment(assessmentData) {
        return this.makeRequest('/assessments', {
            method: 'POST',
            body: JSON.stringify(assessmentData)
        });
    }
    
    async getAssessments(limit = 50, offset = 0) {
        return this.makeRequest(`/assessments?limit=${limit}&offset=${offset}`);
    }
    
    async getAssessment(assessmentId) {
        return this.makeRequest(`/assessments/${assessmentId}`);
    }
    
    async deleteAssessment(assessmentId) {
        return this.makeRequest(`/assessments/${assessmentId}`, {
            method: 'DELETE'
        });
    }
    
    /**
     * Transformation endpoints
     */
    async startTransformation(transformationData) {
        return this.makeRequest('/transformations', {
            method: 'POST',
            body: JSON.stringify(transformationData)
        });
    }
    
    async updateTransformation(transformationId, updateData) {
        return this.makeRequest(`/transformations/${transformationId}`, {
            method: 'PUT',
            body: JSON.stringify(updateData)
        });
    }
    
    async completeTransformation(transformationId, completionData) {
        return this.makeRequest(`/transformations/${transformationId}/complete`, {
            method: 'POST',
            body: JSON.stringify(completionData)
        });
    }
    
    async getTransformations(limit = 50, offset = 0) {
        return this.makeRequest(`/transformations?limit=${limit}&offset=${offset}`);
    }
    
    /**
     * Progress endpoints
     */
    async getProgressData(timeframe = '30d') {
        return this.makeRequest(`/progress?timeframe=${timeframe}`);
    }
    
    async getProgressStats() {
        return this.makeRequest('/progress/stats');
    }
    
    async getProgressInsights() {
        return this.makeRequest('/progress/insights');
    }
    
    /**
     * AI endpoints
     */
    async getChaosAssessment(inputData) {
        return this.makeRequest('/ai/chaos-assessment', {
            method: 'POST',
            body: JSON.stringify(inputData)
        });
    }
    
    async getPersonalizedInsights(userData) {
        return this.makeRequest('/ai/insights', {
            method: 'POST',
            body: JSON.stringify(userData)
        });
    }
    
    async getRecommendations(userProfile) {
        return this.makeRequest('/ai/recommendations', {
            method: 'POST',
            body: JSON.stringify(userProfile)
        });
    }
    
    /**
     * User profile endpoints
     */
    async getUserProfile() {
        return this.makeRequest('/user/profile');
    }
    
    async updateUserProfile(profileData) {
        return this.makeRequest('/user/profile', {
            method: 'PUT',
            body: JSON.stringify(profileData)
        });
    }
    
    async getUserPreferences() {
        return this.makeRequest('/user/preferences');
    }
    
    async updateUserPreferences(preferences) {
        return this.makeRequest('/user/preferences', {
            method: 'PUT',
            body: JSON.stringify(preferences)
        });
    }
    
    /**
     * Export/Import endpoints
     */
    async exportUserData() {
        return this.makeRequest('/user/export');
    }
    
    async importUserData(importData) {
        return this.makeRequest('/user/import', {
            method: 'POST',
            body: JSON.stringify(importData)
        });
    }
    
    /**
     * Health check endpoint
     */
    async healthCheck() {
        return this.makeRequest('/health', {
            requireOnline: false
        });
    }
    
    /**
     * Offline queue management
     */
    addToOfflineQueue(endpoint, options, requestId) {
        this.requestQueue.push({
            endpoint,
            options,
            requestId,
            timestamp: Date.now()
        });
        
        this.log('Added request to offline queue', { endpoint, requestId });
    }
    
    async processOfflineQueue() {
        if (this.requestQueue.length === 0) return;
        
        this.log('Processing offline queue', { queueSize: this.requestQueue.length });
        
        const requests = [...this.requestQueue];
        this.requestQueue = [];
        
        for (const request of requests) {
            try {
                await this.makeRequest(request.endpoint, request.options);
                this.log('Offline request processed', { requestId: request.requestId });
            } catch (error) {
                // If it fails again, add back to queue
                this.requestQueue.push(request);
                this.log('Offline request failed again', { requestId: request.requestId });
            }
        }
    }
    
    /**
     * Retry queue management
     */
    addToRetryQueue(endpoint, options, requestId) {
        this.retryQueue.push({
            endpoint,
            options,
            requestId,
            timestamp: Date.now(),
            attempts: 0
        });
        
        this.log('Added request to retry queue', { endpoint, requestId });
    }
    
    setupRetrySystem() {
        // Process retry queue every 30 seconds
        setInterval(() => {
            this.processRetryQueue();
        }, 30000);
    }
    
    async processRetryQueue() {
        if (this.retryQueue.length === 0) return;
        
        const now = Date.now();
        const requests = this.retryQueue.filter(request => {
            const timeSinceAttempt = now - request.timestamp;
            const retryDelay = Math.min(1000 * Math.pow(2, request.attempts), 30000); // Exponential backoff
            
            return timeSinceAttempt >= retryDelay && request.attempts < 3;
        });
        
        for (const request of requests) {
            request.attempts++;
            request.timestamp = now;
            
            try {
                await this.makeRequest(request.endpoint, request.options);
                
                // Remove from retry queue on success
                this.retryQueue = this.retryQueue.filter(r => r.requestId !== request.requestId);
                this.log('Retry request succeeded', { requestId: request.requestId });
                
            } catch (error) {
                this.log('Retry request failed', { 
                    requestId: request.requestId, 
                    attempts: request.attempts 
                });
                
                // Remove from retry queue if max attempts reached
                if (request.attempts >= 3) {
                    this.retryQueue = this.retryQueue.filter(r => r.requestId !== request.requestId);
                }
            }
        }
    }
    
    /**
     * Utility methods
     */
    generateRequestId() {
        return 'req_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }
    
    getCsrfToken() {
        // Try to get CSRF token from meta tag or cookie
        const metaTag = document.querySelector('meta[name="csrf-token"]');
        if (metaTag) {
            return metaTag.getAttribute('content');
        }
        
        // Or from cookie
        const matches = document.cookie.match(/csrf_token=([^;]+)/);
        return matches ? matches[1] : null;
    }
    
    /**
     * Local storage fallback for offline mode
     */
    async saveToLocalStorage(key, data) {
        try {
            const storageData = {
                data: data,
                timestamp: Date.now(),
                synced: false
            };
            
            localStorage.setItem(`wooc_offline_${key}`, JSON.stringify(storageData));
            this.log('Data saved to local storage', { key });
        } catch (error) {
            this.log('Error saving to local storage', { key, error });
        }
    }
    
    async getFromLocalStorage(key) {
        try {
            const stored = localStorage.getItem(`wooc_offline_${key}`);
            if (stored) {
                return JSON.parse(stored);
            }
        } catch (error) {
            this.log('Error reading from local storage', { key, error });
        }
        
        return null;
    }
    
    async syncLocalStorage() {
        const keys = [];
        
        // Find all offline storage keys
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith('wooc_offline_')) {
                keys.push(key);
            }
        }
        
        // Sync each item
        for (const fullKey of keys) {
            const key = fullKey.replace('wooc_offline_', '');
            const stored = await this.getFromLocalStorage(key);
            
            if (stored && !stored.synced) {
                try {
                    // Attempt to sync data
                    // This would depend on the specific data type
                    this.log('Syncing local storage item', { key });
                    
                    // Mark as synced
                    stored.synced = true;
                    localStorage.setItem(fullKey, JSON.stringify(stored));
                    
                } catch (error) {
                    this.log('Error syncing local storage item', { key, error });
                }
            }
        }
    }
    
    /**
     * Get API status
     */
    getApiStatus() {
        return {
            isOnline: this.isOnline,
            hasSession: !!this.sessionToken,
            queueSize: this.requestQueue.length,
            retryQueueSize: this.retryQueue.length,
            baseUrl: this.baseUrl
        };
    }
    
    /**
     * Log API events
     */
    log(message, data = null) {
        const timestamp = new Date().toISOString();
        console.log(`[WOOCApi] [${timestamp}] ${message}`, data);
        
        // Store API logs for debugging
        try {
            const logs = JSON.parse(localStorage.getItem('wooc_api_logs') || '[]');
            logs.push({
                timestamp: timestamp,
                message: message,
                data: data
            });
            
            // Keep only last 100 logs
            if (logs.length > 100) {
                logs.splice(0, logs.length - 100);
            }
            
            localStorage.setItem('wooc_api_logs', JSON.stringify(logs));
        } catch (error) {
            console.error('Error storing API log:', error);
        }
    }
}

// Initialize global API client
window.woocApi = new WOOCApi();

// Export for use by other modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = WOOCApi;
}